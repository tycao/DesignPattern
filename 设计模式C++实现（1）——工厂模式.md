设计模式C++实现（1）――工厂模式
===========
时间：2018-04-28 12:08<br />
前言：当我第一次接触设计模式的时候，是看的程杰的 `<<大话设计模式>>` 那本书。虽然整本书都是用C#语言实现的，但是真的是很生动有趣。所以在看这本书的时候，就像是在看小说。<br />
背景：明天就开始正式进入五一劳动节的假期之旅了（04/28 -- 05/01）。这几天也没有什么特殊安排，因此就想好好梳理下设计模式相关的知识。<br />

## 工厂模式
工厂模式属于创建型模式，大致分为3类：`简单工厂模式`、`工厂方法模式`、`抽象工程模式`。听上去差不多，都是工厂模式。接下来我们依次介绍这三种工厂模式的不同应用场景。<br /><br /><br />
***********
### 简单工厂模式：
首先介绍简单工厂模式：它的主要特点是需要在工厂类中作判断，然后创造相应的产品。当增加新产品时，则需要修改工厂类。有点抽象(seems that kind of abstract)，举个类子就明白了：<br />
有一家生产不同产品的厂家，它只有一个工厂，能够生产两种产品。客户需要哪种类型的产品，需要显示地告诉生产厂商。下面给出一种实现方案：
```cpp
/** 
 * 简单工厂方法 
 * filename : main.cpp
*/
#include <iostream>
using namespace std;

// 创建一个枚举类型
enum class CTYPE {COREA, COREB};

// 抽象基类 ： 不能直接实例化此类
class SingleCore {
public:
    // 纯虚函数
    virtual void show() = 0;
};   

// A产品
class SingleCoreA : public SingleCore {
public:
    void show() { cout << "SingleCoreA...\n"; }
};

// 产品B
class SingleCoreB : public SingleCore {
public:
    void show() { cout << "SingleCoreB...\n"; }
};

//唯一的工厂，可以生产两种型号的处理器核，在内部判断    
class Factory {
public:
    SingleCore* CreateSingleCore(enum CTYPE ctype) {
        switch (ctype) {
            case CTYPE::COREA:      return new SingleCoreA; // 生产A
                break;
			case CTYPE::COREB:          return new SingleCoreB; // 生产B
					break;
			default:                    return nullptr;         // 不生产
        }
    }
};

int main(int argc, char *argv[])
{
    Factory factory;
    SingleCore* a = factory.CreateSingleCore(CTYPE::COREA);
    a->show();
    return 0;
}
```
!["DP1_1"](https://github.com/tycao/DesignPattern/blob/master/src/DP1_1.png "DP1_1")<br />

### 总结：
这样设计的缺点是：当需要增加新的产品类型时，就需要修改工厂类。这样就违反了`开放-封闭原则`--- **软件实体（类、模块、函数），可以扩展，但不可以修改。** 于是，`工厂方法模式`应运而生。<br />
所谓工厂方法模式，是指`定义一个用于创建对象的接口，让子类决定实例化哪一个类。`  通俗点说就是：`定义一个接口（抽象基类在C++中就是接口的角色），然后定义不同的子类继承自这个接口。来实现具体实例化哪个类型的产品。`
*********
### 工厂方法模式：
接下来介绍工厂方法模式：这家生产不同产品的厂家赚了不少钱，于是决定再开设一个工厂专门用来生产B型号的产品，而原来的工厂专门用来生产A型号的产品。这时，客户要做的是找好工厂，比如要A型号的产品，就找A工厂要；否则找B工厂要，不再需要告诉工厂具体要什么型号的产品了。下面给出一个实现方案。<br />
```cpp
/**
 * 工厂方法模式
 * filename : main.cpp
*/
#include <iostream>
using namespace std;

// 抽象基类：不能直接实例化抽象基类
class SingleCore {
public:
    virtual void show() = 0;
};

// 产品A
class SingleCoreA : public SingleCore {
public:
    void show() { cout << "SingleCoreA...\n"; }
};

// 产品B
class SingleCoreB : public SingleCore {
public:
    void show() { cout << "SingleCoreB...\n"; }
};


// 工厂类 ： 抽象基类
class Factory {
public:
    virtual SingleCore* CreateSingleCore() = 0;
};

// A产品 工厂类
class FactoryA : public Factory {
public:
    SingleCore* CreateSingleCore() {
        return new SingleCoreA;
    }
};

// B产品 工厂类
class FactoryB : public Factory {
public:
    SingleCore* CreateSingleCore() {
        return new SingleCoreB;
    }
};

/**
 * 主函数入口 
*/
int main(int argc, char *argv[])
{
    SingleCore* aPtr = FactoryA().CreateSingleCore();
    aPtr->show();

    SingleCore* bPtr = FactoryB().CreateSingleCore();
    bPtr->show();

    return 0;
}
```
!["DP1_2"](https://github.com/tycao/DesignPattern/blob/master/src/DP1_2.png "DP1_2")<br />

### 总结：
工厂方法模式也有缺点。







